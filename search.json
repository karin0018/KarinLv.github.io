[{"title":"MySQL - 关系模型","url":"/2021/02/05/mysql-RelationalModel/","content":"\n\n关系模型本质上是若干个存储数据的二维表。\n\n表的每一行称为 **记录（Record）**，每一列称为 **字段（Column）**。\n\n字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为 NULL（表示字段数据不存在）。\n\n关系数据库中，关系是通过 **主键** 和 **外键** 来维护的。\n\n<!--more-->\n\n**RDBMS（关系数据库管理系统）的特点：**\n\n1. 数据以表格形式出现\n2. 每行为一条记录\n3. 每列为字段名称对应的数据域（每列数据类型相同）\n4. 行和列组成表单（数据矩阵）\n5. 若干表单组成 database\n\n## 主键\n\n关系表中的每一条记录都包含若干字段。同一个表的所有记录都有相同的字段定义。\n\n关系表的约束：表中任意两条记录不能重复。\n\n> 不能重复不代表不存在两条完全相同的记录，而是指当两条记录不同时，要能通过**某个字段 唯一**区分出他们。\n\n主键用来唯一定位记录，故而在记录插入表中之后，不能轻易修改。\n\n选取主键的**基本原则**：不使用任何业务相关的字段作为主键（最大程度上避免主键修改的可能性），当然也不能是 NULL。\n\n主键字段一般命名为 id，常见可作为 id 的字段类型：\n\n1. 自增整数类型：数据库会在插入数据时自动为每个记录分配一个自增整数。\n2. 全局 GUID 类型：使用一种全局唯一的字符串作为主键。类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。\n\n> 对于大部分应用来说，通常自增类型的主键就能满足需求。\n>\n> BIGINT 自增类型最多可以记录 922亿亿条记录。\n\n\n\n## 联合主键\n\n顾名思义，联合主键就是用多个字段来唯一标识记录，这些字段共同组成主键，就叫联合主键。\n\n对于联合主键，允许有一列重复，只要不是所有主键列都重复即可。\n\n> 说白了就是互相帮助。你不行了我上，但是不能都不行。\n\n联合主键的存在会提高关系表的复杂度，所以不常用。\n\n\n\n## 外键\n\n### 从 一对多 引入\n\n一个班级对应多个学生，是典型的 “一对多” 关系。即一个`classes`的记录可以对应多个`students`表的记录。\n\n为了表达这种一对多的关系，我们需要在`students`表中加入一列`class_id`，让它的值与`classes`表的某条记录相对应。\n\n这样，我们就可以根据`class_id`这个列直接定位出一个`students`表的记录应该对应到`classes`的哪条记录。\n\n在`students`表中，通过`class_id`的字段，可以把数据与另一张表关联起来，这种列称为 **外键**。\n\n外键在数据库中的两种表现形式：\n\n1. 名副其实的外键：\n\n    定义了外键约束\n\n    ```sql\n    ALTER TABLE students\n    ADD CONSTRAINT fk_class_id\n    FOREIGN KEY (class_id)\n    REFERENCES classes (id);\n    ```\n\n    - 外键约束的名称 `fk_class_id` 可以任意。\n    - `FOREIGN KEY (class_id)` 指定了 `class_id` 作为外键。\n    - `REFERENCES classes (id)` 指定了这个外键将关联到 `classes` 表的 `id` 列（即 `classes` 表的主键）。\n\n    删除外键约束，通过 `ALTER TABLE实现`：\n\n    ```sql\n    ALTER TABLE students\n    DROP FOREIGN KEY fk_class_id;\n    ```\n\n    这里没有删除外键这一列，只是删除约束而已。删除列是通过`DROP COLUMN ...`实现的。\n\n2. 逻辑上的外键：\n\n    外键约束会降低数据库的性能，所以为了追求速度，不设置外键约束，而仅靠应用程序自身来保证逻辑的正确性。\n\n    这时 （1）中的 `class_id` 就只是普通的列，而只是在逻辑意义上起到了外键的作用而已。\n\n### 多对多\n\n多对多关系实例：一个老师对应多个班级，一个班级也可以对应多个老师。因此班级和老师之间存在多对多关系。\n\n多对多关系是通过两个一对多关系实现的：有一个中间表，关联两个一对多关系。\n\n### 一对一\n\n一对一关系：一个表的记录对应到另一个表的唯一一个记录。\n\n这样的表可以根据外键合并也可以拆分。\n\n\n\n> 综上，关系数据库通过外键可以实现一对多，多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅靠应用陈旭的逻辑实现。\n\n\n\n## 索引\n\n在关系数据库中存有多条记录，为了快速的找到某条记录，我们使用索引。\n\n**索引**：关系数据库中对某一列或多个列的值进行预排序的数据结构。可在查找记录时直接定位到符合条件的记录，大大加快查询速度。\n\n例如，对 `students` 表：\n\n- id 学号\n- class_id 班级\n- name 姓名\n- gender 性别\n- score 成绩\n\n如果要经常根据`score`列进行查询，就可以对`score`列创建索引：\n\n```sql\nALTER TABLE students\nADD INDEX idx_score (score);\n```\n\n使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`，使用列`score`的索引。\n\n索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：\n\n```sql\nALTER TABLE students\nADD INDEX idx_name_score (name, score);\n```\n\n**索引的效率取决于索引列的值是否散列，对于主键，因为主键保证绝对唯一，所以使用主键索引效率最高。**\n\n**关系数据库会自动对其创建主键索引。**\n\n> 虽然索引提高了查询效率，但是在插入、更新和删除记录使，需要同时修改索引。故而索引越多，插入等操作的速度就会更慢。\n\n### 唯一索引\n\n根据业务要求，具有唯一性约束的列（例如身份证号码）可以添加唯一索引，**从而保证这一列的值具有唯一性**。例如学生的身份证号不能重复：\n\n```sql\nALTER TABLE students\nADD UNIQUE INDEX uni_pid (pid);\n```\n\n> 通过 unique 关键字添加唯一索引\n\n也可以只添加唯一约束不创建唯一索引：\n\n```sql\nALTER TABLE students\nADD CONSTRAINT uni_pid UNIQUE (pid);\n```\n\n添加索引只不过是让数据库的查询锦上添花，没有索引数据库当然也能正常运行，因此索引可以在使用数据库的过程中逐步优化。\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"NLP 学习笔记-2","url":"/2021/02/02/nlp-learning-2/","content":"\n# 近似训练\n\n跳字模型的核心在于用 softmax 运算得到给定中心词 $w_c$ 来生成背景词 $w_o$ 的条件概率：\n\n$P(w_o \\mid w_c) = \\frac{\\text{exp}(\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c)}{ \\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)}.$\n\n该条件概率相应的对数损失：\n\n$-\\log P(w_o \\mid w_c) = -\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c + \\log\\left(\\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)\\right).$\n\n从公式中可以看出，softmax 运算考虑了背景词可能是词典 V 中的任何一个词，所以损失的计算中包含了词典所有项的累加，那么对于上千万的较大词典，每次计算梯度的开销过大。\n\n为降低计算复杂度，下面介绍两种近似训练方法：负采样（negative sampling）和层序 softmax（hierarchical softmax）。\n\n<!--more-->\n\n## 负采样\n\n\n\n# 似然函数\n\n似然函数是一种关于统计模型中的参数的函数，注意，他关注的是模型中的参数，表示模型参数的似然性。\n\n主要思想是，在已知某些观测所得到的结果时，对有关事物之性质的参数进行估值：`结果 -> 函数参数`\n\n似然函数可以理解为条件概率的逆反：条件概率是已知某个参数的值，计算发生某件事情的概率；似然函数则是根据事情发生的结果，估计参数可能是哪个值；\n\n实际生活中，当然是根据现象得出结论的情况更多。\n\n**似然函数的重要性不是它的具体取值，而是当参数变化时函数到底变小还是变大。**\n\n**对于同一个似然函数，其所代表的模型中，某项参数值有多种可能，但如果存在一个参数值，使得它的函数值（似然函数的函数值）达到最大，那么这个值就是该项参数最为 “合理”的值。**\n\n## 最大似然估计\n\n1. 选取似然函数（一般是概率密度函数或者概率质量函数）\n2. 求最大值点；一般会取 **似然函数的对数作为求最大值的函数**，这样求出来的最大值点和直接求的最大值点得到的结果相同。\n\n","tags":["NLP"],"categories":["基础知识学习"]},{"title":"NLP 学习笔记-1","url":"/2021/01/30/nlp-learning-1/","content":"\n# 词嵌入 word2vec\n\n**基于 [动手深度学习](http://zh.gluon.ai/chapter_natural-language-processing/word2vec.html)**\n\n词，是自然语言中表意的基本单元。\n\n词向量是用来表示词的向量，也可被认为是词的特征向量或表征。\n\n> 个人理解为描述 词 的一种方式\n\n词嵌入：把词映射为实数域向量的技术。\n\nword2vec 包含跳字模型和连续词袋模型。跳字模型假设基于中心词来生成背景词；连续词袋模型假设基于背景词来生成中心词。\n\n<!--more-->\n\n##  为什么不用 one-hot 向量？\n\n **one-hot 向量：**\n\n假设词典中不同字符的数量为 N，每个字符已经同一个从 0 到 N-1 的连续数值索引一一对应。\n\n如果一个字符对应的索引是 i，那么该字符对应的 one-hot 向量的第 i 位就设置为 1，其余位为 0；\n\n譬如若字库里仅有 apple（苹果），banana（香蕉），以及 pineapple（凤梨）这三个单字，则他们各自的 one-hot 向量可以为：\n\n```\napple = [1,0,0]\nbanana = [0,1,0]\npineaplle = [0,0,1]\n```\n\n> 由于电脑无法理解非数字类的数据，One-hot 编码可以将类别性数据转换成统一的数字格式，方便机器学习的算法进行处理及计算。而转换成固定维度的向量则方便机器学习算法进行线性代数上的计算。\n>\n> 另外由于一个 one-hot 向量中，绝大部分的数字都是0，所以若使用[稀疏矩阵](https://zh.wikipedia.org/wiki/稀疏矩阵)的数据结构，则可以节省电脑内存的使用量。\n\n**one-hot 向量的缺点：**\n\n虽然构造起来容易，但是 one-hot 词向量无法准确表达不同词之间的相似度（例如 余弦相似度）。\n\n**word2vec 工具的提出正是为了解决这个问题：**\n\n他将每个词表示成一个定长的向量，并使得这些向量能较好地表达不同词之间的相似和类比关系。\n\n他包含**跳字模型**和**连续词袋模型**两个模型。\n\n\n\n## 跳字模型\n\n### 核心思想\n\n基于某个词来生成它周围的词。\n\n例如，现有文本序列 `the man loves his son `给定中心词 love，设置窗口大小为 2，跳字模型关心的是，给定中心词 love，生成与它距离不超过两个词的背景词 the,man,his,son 的条件概率，即：\n\n$P('the','man','his','son' | 'love')$\n\n### 数学模型\n\n每个词被表示成两个 d 维向量，用来计算条件概率。\n\n假设某个词的词典索引为 i，它中心词时向量表示为 $v_i$ ，为背景词时向量表示为 $u_i$。\n\n设中心词 $w_c$ 在词典中索引为 $c$，背景词 $w_o$ 在词典中索引为 $o$，**给定中心词生成背景词的条件概率**可以通过对向量内积做 softmax 运算而得到：\n\n$P(w_o \\mid w_c) = \\frac{\\text{exp}(\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c)}{ \\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)},$\n\n> softmax 函数（归一化指数函数）：能将一个含任意实数的 K 维向量 z 压缩到另一个 K 维实向量 $\\delta(z)$ 中，使得每个元素的范围都在 (0,1) 之间，并且所有元素的和为 1 函数形式通常如下：\n>\n> $\\delta(z)_j = \\frac{e^{z_j}}{\\sum_{k=1}^{K} e^{z_k}}$  for j = 1,…, K.\n\n词典索引集为 $V = {0,1,2,...,|V|-1}$. 设给定一个长度为 T 的文本序列，设时间步 t 的词为 $w^{(t)}$ 。\n\n假设给定中心词的情况下背景词的生成相互独立，当背景窗口大小为 m 时，跳字模型的似然函数 【即给定任一中心词生成所有背景词的概率】：\n\n$\\prod_{t=1}^{T} \\prod_{-m \\leq j \\leq m,\\ j \\neq 0} P(w^{(t+j)} \\mid w^{(t)}),$\n\n\n\n### 训练跳字模型\n\n说实话这块每太看明白。。。\n\n最小化损失函数我懂，需要计算梯度来更新模型参数我也明白；\n\n为了计算梯度，我们需要词典中所有词以 $w_c$ 为中心词的条件概率这我也知道。\n\ndei某，怎么算这个条件概率嘞？按照公式的话我们是需要知道背景词向量 $u_j$ 和中心词向量 $v_c$ 的。但是他又说：\n\n> 训练结束后，对于词典中的任一索引为 i 的词，我们均得到该词作为中心词和背景词的两组词向量 $v_i$ 和 $u_i$。\n>\n> 我：？？？ 这不是循环计算？真的能得出结果吗\n>\n> 在自然语言处理应用中，一般使用跳字模型的中心词向量作为词的表征向量。\n\n## 连续词袋模型\n\n### 核心思想\n\n基于中心词在文本序列前后的背景词来生成该中心词；\n\n> 背景词 -> 中心词\n\n$P('love'|'the','man','his','son' )$\n\n\n\n数学模型和训练方式我就不搬运了，整体思路同上。\n\n\n\n据说这里看不懂可以看一篇论文 [word2vec Parameter Learning Explained](<a href=\"w2vexp.pdf\" download=\"w2vexp.pdf\">点击下载</a>)\n\n\n\n等我回头就来看","tags":["NLP"],"categories":["基础知识学习"]},{"title":"NLP 学习笔记 - 0","url":"/2021/01/30/nlp-learning/","content":"# 综述\n\n本章中，根据输入与输出的不同形式，按照 定长到定长，不定长到定长，不定长到不定长的顺序，逐步展示在自然语言处理中如何表征并变换定长的词或类别以及不定长的句子或段落序列。\n\n<!--more-->\n1. 如何用向量表示词 + 在语料库上训练词向量。\n2. 将词向量应用于求近义词和类比词 - 定长到定长\n3. 用词向量来分析文本情感：基于循环神经网络和卷积神经网络来表征时序数据\n4. 不定长到不定长任务：编码器-解码器模型、束搜索和 attention 机制\n\n","tags":["NLP"],"categories":["基础知识学习"]},{"title":"MySQL 安装教程 + 排坑","url":"/2021/01/27/mysql-install/","content":"**本教程基于 windows10(64位) 操作系统**\n\n# 下载\n\n1. 访问 [官网下载地址](https://dev.mysql.com/downloads/mysql/)\n   {% asset_img 1.PNG This is an download image %}\n\n2. 点击 `No thanks,just start my download` 跳过注册过程，直接下载压缩包。\n\n<!--more-->\n# 安装与配置\n\n- 在指定路径解压，将解压后 bin 文件的路径（`D:\\mysql-8.0.23-winx64\\bin`）添加到系统环境变量中：\n  > 我的电脑->属性->高级->环境变量\n  > 选择PATH,在其后面添加: 你的 mysql bin 文件夹的路径\n- 使用管理员身份打开 cmd：\n  > 在开始菜单中输入 cmd，选择用管理员身份打开；\n- 跳转到 mysql bin 目录下：\n  {% asset_img 2.PNG This is an bin path %}\n- 安装 mysql\n  ```\n  mysqld -install\n  ```\n- 初始化 mysql（一定要初始化！否则容易导致启动不成功）\n  ```\n  mysqld --initialize\n  ```\n- 启动服务\n  ```\n  net start mysql\n  ```\n  {% asset_img 3.PNG This is an start successfully image %}\n\n  > 这里直接写 mysql 是因为我主机服务中 mysql 的服务名就是 mysql，如果大家出现了启动不成功的情况可以自行搜索是不是服务名不同。\n\n- 登录 mysql：\n  ```\n  mysql -u root -p\n  ```\n  据说第一次登录不需要密码，直接按回车就好了，但是博主按了回车发现不行。出现报错 `ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)`\n  {% asset_img 4.PNG This is an start failed image %}\n  看来还是需要我们输入密码，下面一起找密码吧：\n  1. 打开 mysql 的根目录下名为 data 的文件夹；\n  2. 找到以 `.err` 为结尾的文件（专门记录报错信息的）并打开；\n  3. 找到自动生成的密码啦！\n   {% asset_img 5.PNG This is an password image %}\n  4. 输入密码即可~\n   {% asset_img 6.PNG This is an load successfully image %}\n\n# 通过 vscode 连接 mysql\n\n旨在利用 vscode 能更加便捷的编写并执行 SQL 代码。\n\n参考文章：[MySQL vscode开发环境搭建](https://zhuanlan.zhihu.com/p/347159257)\n\n## 基础知识\n\n> MySQL 相当于一个 shell，SQL 就是和 shell 交互的脚本语言。\n> 众所周知，与 shell 打交道的方式有两种：\n> - 一种是直接在shell中输命令执行，但是这样很难让我们看到多条shell的作用。\n> - 还有一种方式是编写 shell 脚本。在 bash 中，shell 脚本的文件名后缀可以是 .sh，在 MySQL 中，脚本的后缀名为 .sql\n\n## 安装插件\n\n1. 打开 vscode 插件商店；\n2. 搜索并安装如下两个插件：\n   - MySQL [by Jun Han]\n   - MySQL Syntax [by Jake Bathman]\n3. 以管理员身份打开 cmd；\n4. `net start mysql` 启动服务；\n5. `mysql -u root -p` 进入 MySQL 账户（密码的查找方式见上）\n6. 进入 mysql 的 shell 之后，输入命令：\n   ```\n    alter user 'root'@'localhost' identified with mysql_native_password by '123456';\n   ```\n   重置密码为 `123456`\n\n## vscode 连接本机数据库\n\n1. 打开 vscode ，点击左下角的 MYSQL 旁边的加号：\n   {% asset_img 7.PNG This is an load successfully image %}\n\n2. 在弹出的对话框中设置参数：\n   - host: 127.0.0.1\n   - username: root\n   - password: 123456 (刚设置的)\n   - 其他参数保持默认，一路回车下去\n\n## 一个栗子\n\n1. 在 MYSQL 下方的蓝色饼饼图标处右键，选择 new_query\n2. 在弹出的编辑栏中输入 SQL 指令，并以 `.sql` 为后缀名保存到本地\n3. 编辑区右键，选择 Run MySQL query\n4. 你会在编辑区右侧看到指令的执行结果。\n\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"hexo+stun 博客搭建","url":"/2021/01/26/hexo-stun/","content":"\n# 背景\n\n看到某位同学搭了自己的博客，觉得有一个记录自己成长路线的博客好像挺香的…刚好寒假时间比较充裕，是个动手的好时机~\n\nGithub Pages 功能 +  Hexo 的博客框架 + 自己喜欢的主题 = 华而有实的博客\n\n<!--more-->\n\n使用 Github Pages 搭建博客的好处：\n\n1. 免费，免费，免费！\n2. 都是静态文件，访问速度较优；\n3. 能和 git 搭配使用，管理起来都是熟悉的配方；\n\n使用 hexo 的好处：\n\n1. 简洁高效，安装简单；\n2. 有多种稳定、美观的主题可以挑选；\n3. 使用 Markdown 解析文章，符合自己平时写东西的习惯；\n\n> 当然其他框架也有各自的优点，这个选择凭各自喜好啦~\n\n**本教程以 windows 为例**\n\n\n# Github Pages\n\n**基于 [Github Pages 官方文档](https://docs.github.com/cn/github/working-with-github-pages/creating-a-github-pages-site)**\n\n前提是要有 github 账号，没有的同学们可以先去注册一个~\n\n1. 创建 Github Pages 站点：\n\n    - 新建一个仓库；\n    - 输入仓库的名称和说明（可选）。 如果您创建的是用户或组织站点，仓库名称**必须为** `<user>.github.io` 或 `<organization>.github.io` ；\n    - 设置仓库属性为 `public` ;\n    - 选择 `Initialize this repository with a README`（使用 readme 文件初始化此仓库；\n    - `create repository`\n\n2. 设置站点：\n\n    - 在站点仓库下，找到右上角 `Settings`\n\n    - 下滑，找到`Github Pages`选项卡，你能看到站点的 url 啦~\n        {% asset_img 1-1.jpg This is an github-pages image %}\n        > 这个 url 就是你网站的地址，通过它，大家就能访问到你的博客。\n\n    - Source 栏的 branch 选择 main（或者 master，总之就是除了 none 之外的那个），点击 save；\n\n    - Theme Chooser 那个不用管，因为后续要使用 hexo 的主题嘛；\n\n    - 将仓库克隆到本地，用 git 配置自己的身份信息：\n\n        ```\n        git config --global user.name \"github user name\"\n        git config --global user.email \"github user email\"\n        ```\n\n    - [添加 ssh-key](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)（注意不要设置密码）主要是为了以后 hexo 发布比较方便。\n\n\n\n# hexo\n\n**基于 [hexo](https://hexo.io/zh-cn/docs/) 官方文档**\n\n## 安装\n\n安装 hexo 之前，先来把环境搞好：\n\n- 安装 [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- 安装 Git （ 不过 github 那一步都搞好了，这里就不用了吧~）\n\n> 这里具体的安装细节提示可以直接参考各自官方文档，或者网上找找教程。\n\n现在可以安装 hexo。\n\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在`D:/blog`目录下。\n\n我使用 Windows 自带的控制台定位到`D:/blog`目录下执行以下操作：\n\n```\n$npm install -g hexo-cli\n```\n\n> 据说 linux 和 max 里是要在前面加个 sudo，不然会因为权限问题报错。\n\n装完输入 `hexo --version` 检查是否安装成功。\n\n## 建站\n\n`hexo init` 初始化文件夹；\n\n`npm install` 安装必须的插件；\n\n`hexo g` 生成静态文件；\n\n`hexo s` 将静态文件运行在本地服务器上，这个时候根据提示打开 `localhost:4000` 就能看到最基本的博客啦~\n\n`ctrl+c` 关闭本地服务器；\n\n## 与 github 连接\n\n打开 blog 根目录下的 `_config.yml` 文件，修改配置：\n\n```yml\n# URL\n## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'\nurl: https://github.com/xxx/xxx.github.io/\nroot: /xxx.github.io/\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from\n\n...\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:xxx/xxx.github.io.git\n  branch: main\n```\n\n还是在 blog 根目录下：\n\n```c\nhexo g // 编译生成静态文件（每次修改完都必须重新编译）\nhexo d // 将博客发布到 github 上\n```\n\n现在可以通过 `https://xxx.github.io` 来访问你的博客啦~\n\n\n\n# 主题 - stun\n\n博主选的是 stun 这个主题，主要是看中了她 ~~可甜可盐~~  活泼大方、简洁美观 的风格，当然她不是最简洁的，最简洁的应该是 Next 这个主题了吧（\n\n这个官方文档超级全的！！！而且步骤都很详细！！！\n\n我在这里就不瞎写了，反正写的没有官网好，照着来没错的，嗯！\n\n官网指路：[stun](https://theme-stun.github.io/docs/zh-CN/guide/quick-start.html#%E5%AE%89%E8%A3%85)\n\n\nemmmm\n\n那我写点推荐和排雷：\n\n## 统计与分析推荐\n\n首推 [谷歌分析](https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#%E8%B0%B7%E6%AD%8C%E5%88%86%E6%9E%90) ！！！ 简单好用不要钱！！！\n\n来一篇好用的配置教程：[Google Analytics怎么用，谷歌分析工具使用教程](https://www.yundianseo.com/how-to-use-google-analytics/)\n\n\n\n## 评论系统推荐\n\n博主尝试了三种评论系统，各自利弊写在下面奥：\n\n1. Disqus\n\n    优点：\n\n    - 配置简单（所以博主最先选的就是这个）\n    - 完善的后台管理机制\n    - 丰富的表情可选\n    - 支持 markdown\n\n    缺点：\n\n    - 服务器在国外，不翻墙加载不出来\n\n    - 存在广告植入\n\n    - 要评论必须有 disqus  / google / Twitter/ facebook 账户\n\n\n\n2. Valine\n\n    优点：\n\n    - 配置简单（但没有 disqus 简单）\n    - 无后端，所以加载起来很快\n    - 页面设计简洁\n    - 评论不用登陆任何账户\n    - 支持 markdown\n\n    缺点：\n\n    - 页面设计过于简洁（我试验过之后才发现，是真的很简洁，白白的，也没有点赞的功能，想要拥有一个头像都要花挺多功夫\n    - 评论可以匿名（某同学说可能会有恶意评论，博主觉得他说的有道理…\n\n\n\n3. Utterances\n\n    优点：\n\n    - 配置看上去复杂但其实很简单：\n\n        将 [utterances app (opens new window)](https://github.com/apps/utterances)安装在你博客对应的 Github 仓库中。然后，按照 stun 官网的提示修改配置项即可；\n\n    - 是一个基于 github issues 的评论系统，管理方便；\n\n    - 支持 emoji 支持评论点赞\n\n    - 支持 markdown\n\n    缺点：\n\n    - 需要登录 github 账户才能评论（是缺点也是优点吧）\n\n## bug 分享\n\n### multiline key\n\n```\n message: 'can not read a block mapping entry; a multiline key may not be an implicit key at line 7, column 9:\\n'\n \"    subtitle: 'If you shed tears when you mi ... \\n\" +\n```\n\n网上大部分说是在对应位置缺了英文空格，但我不是这个错…\n\n这里要注意，错误可能不在这一行，可能出现在它前一行：\n\n```yml\ntitle: 'Karin Lv's Blog'\nsubtitle: 'If you shed tears...\n```\n\n我就是出现在它上一行的，这里单引号中间还有一个单引号，不符合语法规则了，所以报错…\n\n去掉外层的单引号就好了！\n\n### invalid characters\n\n出现非法字符，大概率是因为在配置文件里写了中文，但没有相应的设置。\n\n博主的做法比较简单粗暴：配置文件里尽量不写中文，都改成英文 QAQ\n\n> 大家可以在网上搜一下更专业的解决办法，不要学这个懒博主（\n\n","tags":["博客搭建"],"categories":["教程类"]},{"title":"计算机网络复习 - 网络层","url":"/2021/01/26/ComputerNetworkReview-Chap4/","content":"\n# 综述\n\n通过学习这一章节，我们需要了解以下两方面内容：\n\n理解网络层服务原理：\n- 网络层服务模型\n- 网络层上的重要功能：转发和选路\n- 路由器工作原理\n- 选路算法\n\n因特网的网络层协议：\n- IP 协议\n- ICMP 协议\n- 选路协议：RIP,OSPF,BGP\n<!--more-->\n\n#  概念简介\n\n1. 网络层的**作用**：将报文段从**发送主机**传送到**接收主机**。\n\n> 每一台主机和路由器都运行网络层协议。\n>\n> 路由器：将分组从输入链路转发到输出链路。它运行的协议包括，网络层，链路层，物理层。\n>\n> 发送主机：将传输层报文段封装到网络层分组中，发送给边缘路由器。\n>\n> 接收主机：从边缘路由器接收分组，取出报文段交付给传输层。\n\n2. 网络层的主要功能：\n\n    选路：确定分组从源路由器到目的路由器的路径 – 利用各种**路由算法**来计算转发表。\n\n    转发：将分组从输入端口转移到合适的输出端口 – 根据转发表转运分组。\n\n    > 在传输分组之前，两个端系统需要建立连接。\n    >\n    > - 传输层连接：进程-进程，连接状态仅仅保存在端系统中，传输层服务在网络边缘实现\n    > - 网络层连接：主机-主机，连接状态保存在源主机，目的主机以及所有中间路由器上（路由器要保存转发表的嘛），网络层服务在网络核心实现。\n\n3. 网络服务模型\n\n    定义分组在发送主机与接收主机之间传输时的特性。\n\n    - 对单个分组提供的服务\n\n        >  保证交付；具有时延上界的保证交付；\n\n    - 对分组流提供的服务\n\n        > 有序交付；保证最小带宽；\n        > 保证最大时延抖动（分组端到端时延的最大差异）；\n\n        不同架构的网络提供的网络层服务可能不同，同一个网络也可以提供不同的网络层服务。\n\n# 虚电路和数据报网络\n\n两种基本的网络类型：\n\n**数据报网络**：提供网络层**无连接**服务\n\n**虚电路网络**：提供网络层**面向连接**服务\n\n## 虚电路 Virtual circuits\n\n网络层连接成为虚电路。\n\n虚电路是从源主机到目的主机的一条路径，类似电话电路，每条虚电路有唯一标识（虚电路号），每个分组应该携带虚电路号，表明所属的虚电路。\n\n> 传输**分组前建立虚电路**，传输结束后拆除虚电路;\n>\n> 每个路由器为经过它的虚电路维护状态（转发表项 - 进入端口，进入VC号，输出端口，输出VC号），分组携带 VC 号，每一次转发前用新的 VC 号替换分组中的 VC 号 ;\n>\n> 链路及路由器资源（带宽、缓存等）可以分配给虚电路，从而虚电路能提供**可预期的**网络服务。\n\n**信令协议：**用于 VC  的建立、维护与拆除。\n\n## 数据报网络\n\n- 分组携带目的主机地址，路由器按目的地址转发分组；\n\n- 路由器根据分组的目的地址转发分组，转发表记录目的地址到输出链路的映射；\n\n    > 实际上是存储**目的地址的范围**到**链路**的映射；\n    >\n    > 匹配规则：最长前缀匹配优先；\n\n- 转发表被选路模块修改，约1～5分钟更新一次；\n\n- 同一对主机之间传输的分组可能走不同的路径，从而可能重排序；\n\n## 数据报网络 VS 虚电路网络\n\n数据报网络：\n\n- 计算机之间交换数据：没有严格的时序要求；\n- 终端具有智能：将复杂的工作（如差错控制）推到网络边缘，以保持网络简单。\n\n虚电路网络：\n\n- 由电信网发展而来：严格时序和可靠性要求；\n- 终端无智能或很少智能：复杂工作由网络完成，以保持终端简单。\n\n\n\n# Internet 网络层协议\n\n## internet 网络层\n\n  {% asset_img 1.PNG This is an internet image %}\n\n## IPv4 数据报格式\n\n  {% asset_img 2.PNG This is an IP4 image %}\n\n## IP 数据报分片\n\n### 最大传输单元 MTU\n\nMTU：链路层数据帧可封装数据的上限；$MTU = MAX(data)$\n\n> 不同链路的 MTU 不同\n\n### 分组与重组\n\n大 IP 向比较小的 MTU 链路转发时，可以被分片 （fragmented）。\n\n1. 大 IP 分片成若干小 IP\n2. IP 分片在到达 **目的主机** 后重组（路由器只管分不管组装）\n\nIP 首部相关字段用于标识分片以及确定分片的顺序（便于在目的主机重组 IP 分组）\n\n> 涉及到的字段：总长度、标识、标志和片偏移字段。\n\n- 标识：每个分片必须携带与原始数据报相同的标识。\n- 标志位：\n    - MF（more fragments）：最后一个分片的MF=0，其余分片的 MF=1\n    - DF（don’t fragment）：DF=1 表示不允许对数据报分片\n- 片偏移量（13bits）：指示分片中的数据在原始数据报载荷中的位置（以 8 字节为单位）\n\n**分片的处理过程**\n\n根据报头长度 H 和输出线路的 MTU 为 M，原 IP 分组的总长度为 L 。\n\n一个最大分片可封装的数据为：$d = \\lfloor \\frac{M-20}{8} \\rfloor * 8 ~ Bytes$\n\n需要的总片数为： $n = \\lceil \\frac{L-20}{d} \\rceil$\n\n1. 将数据报的载荷划分成长度为 d 的若干片段（最后一个分片可能不足 d 字节）。\n\n2. 将原始报头加到每一个分片的前面，修改报头中的以下字段：\n\n    $\\text{总长度} = d + 20,  ~(1 <= i < n)$;   $ or = L-(n-1)d, ~(i = n)$\n\n    最后一个报头的 MF 位置 0，其余报头的 MF 位置 1\n\n    偏移量：$F_i = \\frac{d}{8} * (i-1), ~~~ 1\\le i \\le n$\n\n4. 计算头部检查和\n\n## IP 编址\n\n**接口：** 主机 or 路由器 与物理链路的边界。\n\n**IP 地址：**32bit 标识主机、路由器的接口。一般采用点分十进制标识（8位一组，转成十进制），例如：`127.0.0.1`\n\n**如何为接口分配 IP 地址？**\n\n-  IP 地址分为两部分，高位比特为网络号，低位比特为主机号。\n- **IP 子网：** IP 资质具有相同的网络号，**不跨越路由器**，可以彼此物理联通的接口。\n\n### 有类编址\n\n  {% asset_img 3.PNG This is an IP class image %}\n\n\n\nA,B,C 类 IP 地址可以用来给主机或路由器分配网络接口，但也有一些特殊情况。\n\n\n\n {% asset_img 4.PNG This is an IP special image %}\n\n### 子网划分\n\nIP 地址：\n\n- 网络号 NetID - 高位比特\n- 子网号 SubID - 原网络主机号部分比特\n- 主机号 HostID - 低位比特\n\n**如何确定是否划分了子网？利用多少位划分子网？**\n\n- **子网掩码**：形如 IP 地址。**取值：NetID、SubID 全部取 1， HostID 全部取 0**\n\n    > 例如：\n    >\n    > A 网默认子网掩码 ：`255.0.0.0`\n    >\n    > B 网默认子网掩码 ：`255.255.0.0`\n    >\n    > C 网默认子网掩码 ：`255.255.255.0`\n    >\n    > 借用 3 比特划分子网的 B 网的子网掩码：`255.255.224.0`\n\n- 子网地址 + 子网掩码 = 准确确定子网大小\n\n    > 例：将 子网 `201.2.3.0`, `255.255.255.0` 划分为等长的 4 个子网。\n    >\n    > 分析：\n    >\n    > C 网，主机号范围只有最后 8 位（一共可以有 256 个不同的主机号）\n    >\n    > $256 / 4 = 64$，所以将最后 8 位的前两位借为子网号，划分的四个子网如下：\n    >\n    > 1. `201.2.3.0    子网号(00)   255.255.255.192` \n    > 2. `201.2.3.64   子网号(01)   255.255.255.192` \n    > 3. `201.2.3.128  子网号(10)   255.255.255.192` \n    > 4. `201.2.3.192  子网号(11)   255.255.255.192` \n\n### 无类域间路由 CIDR\n\nCIDR (Classless InterDomain Routing)：\n\n- 消除传统的 A、B、C类地址界限：$NetID + SubID->Network~Prefix$\n\n- 融合子网地址与子网掩码，方便子网划分：`a.b.c.d/x` 其中 x 为前缀长度\n\n    > 例如：`200.23.16.0/23`\n    >\n    > C 类地址前 24 位都是网络号，但这里的 CIDR 地址的前缀只有 23 位。\n    >\n    > 实际上它是两个 C 类地址的组合：`200.23.16.0` 和 `200.23.17.0` (第24位分别为 0 和 1)\n\n- 子网 `201.2.2.3.64  255.255.255.192 -> 201.2.3.64/26`\n\n**优点**：\n\n- 提高 IPv4 地址空间分配效率\n\n- 提高路由效率\n    1. 将多个子网聚合为一个较大的子网\n    2. 构造超网（supernetting）\n    3. 路由聚合（route aggregation）\n\n#### 路由聚合\n\n路由表中符合聚合条件的若干条路由可以**合并成一条路由**：\n\n- 这些路由的前缀可以聚合成一个更短的前缀（称地址前缀）\n- 这些路由使用相同的下一跳\n- 路由聚合的过程可以递归进行\n\n  {% asset_img 5.PNG This is an CIDR image %}\n\n\n\n> 若个别路由不满足路由聚合的条件，可以给出一条聚合路由和若干条特定路由。\n>\n> **最长前缀匹配优先**：在所有匹配的路由表项中，选择前缀最长的路由表项。（避免路由黑洞现象【数据到达不了目标地址】）\n>\n>  {% asset_img 6.PNG This is an special CIDR image %}\n\n\n\n##  DHCP 协议\n\n","tags":["计算机网络"],"categories":["复习笔记"]}]