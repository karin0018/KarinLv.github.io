[{"title":"MySQL - 关系模型","url":"/2021/02/05/mysql-RelationalModel/","content":"\n\n关系模型本质上是若干个存储数据的二维表。\n\n表的每一行称为 **记录（Record）**，每一列称为 **字段（Column）**。\n\n字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为 NULL（表示字段数据不存在）。\n\n关系数据库中，关系是通过 **主键** 和 **外键** 来维护的。\n\n<!--more-->\n\n**RDBMS（关系数据库管理系统）的特点：**\n\n1. 数据以表格形式出现\n2. 每行为一条记录\n3. 每列为字段名称对应的数据域（每列数据类型相同）\n4. 行和列组成表单（数据矩阵）\n5. 若干表单组成 database\n\n## 主键\n\n关系表中的每一条记录都包含若干字段。同一个表的所有记录都有相同的字段定义。\n\n关系表的约束：表中任意两条记录不能重复。\n\n> 不能重复不代表不存在两条完全相同的记录，而是指当两条记录不同时，要能通过**某个字段 唯一**区分出他们。\n\n主键用来唯一定位记录，故而在记录插入表中之后，不能轻易修改。\n\n选取主键的**基本原则**：不使用任何业务相关的字段作为主键（最大程度上避免主键修改的可能性），当然也不能是 NULL。\n\n主键字段一般命名为 id，常见可作为 id 的字段类型：\n\n1. 自增整数类型：数据库会在插入数据时自动为每个记录分配一个自增整数。\n2. 全局 GUID 类型：使用一种全局唯一的字符串作为主键。类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。\n\n> 对于大部分应用来说，通常自增类型的主键就能满足需求。\n>\n> BIGINT 自增类型最多可以记录 922亿亿条记录。\n\n\n\n## 联合主键\n\n顾名思义，联合主键就是用多个字段来唯一标识记录，这些字段共同组成主键，就叫联合主键。\n\n对于联合主键，允许有一列重复，只要不是所有主键列都重复即可。\n\n> 说白了就是互相帮助。你不行了我上，但是不能都不行。\n\n联合主键的存在会提高关系表的复杂度，所以不常用。\n\n\n\n## 外键\n\n### 从 一对多 引入\n\n一个班级对应多个学生，是典型的 “一对多” 关系。即一个`classes`的记录可以对应多个`students`表的记录。\n\n为了表达这种一对多的关系，我们需要在`students`表中加入一列`class_id`，让它的值与`classes`表的某条记录相对应。\n\n这样，我们就可以根据`class_id`这个列直接定位出一个`students`表的记录应该对应到`classes`的哪条记录。\n\n在`students`表中，通过`class_id`的字段，可以把数据与另一张表关联起来，这种列称为 **外键**。\n\n外键在数据库中的两种表现形式：\n\n1. 名副其实的外键：\n\n    定义了外键约束\n\n    ```sql\n    ALTER TABLE students\n    ADD CONSTRAINT fk_class_id\n    FOREIGN KEY (class_id)\n    REFERENCES classes (id);\n    ```\n\n    - 外键约束的名称 `fk_class_id` 可以任意。\n    - `FOREIGN KEY (class_id)` 指定了 `class_id` 作为外键。\n    - `REFERENCES classes (id)` 指定了这个外键将关联到 `classes` 表的 `id` 列（即 `classes` 表的主键）。\n\n    删除外键约束，通过 `ALTER TABLE实现`：\n\n    ```sql\n    ALTER TABLE students\n    DROP FOREIGN KEY fk_class_id;\n    ```\n\n    这里没有删除外键这一列，只是删除约束而已。删除列是通过`DROP COLUMN ...`实现的。\n\n2. 逻辑上的外键：\n\n    外键约束会降低数据库的性能，所以为了追求速度，不设置外键约束，而仅靠应用程序自身来保证逻辑的正确性。\n\n    这时 （1）中的 `class_id` 就只是普通的列，而只是在逻辑意义上起到了外键的作用而已。\n\n### 多对多\n\n多对多关系实例：一个老师对应多个班级，一个班级也可以对应多个老师。因此班级和老师之间存在多对多关系。\n\n多对多关系是通过两个一对多关系实现的：有一个中间表，关联两个一对多关系。\n\n### 一对一\n\n一对一关系：一个表的记录对应到另一个表的唯一一个记录。\n\n这样的表可以根据外键合并也可以拆分。\n\n\n\n> 综上，关系数据库通过外键可以实现一对多，多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅靠应用陈旭的逻辑实现。\n\n\n\n## 索引\n\n在关系数据库中存有多条记录，为了快速的找到某条记录，我们使用索引。\n\n**索引**：关系数据库中对某一列或多个列的值进行预排序的数据结构。可在查找记录时直接定位到符合条件的记录，大大加快查询速度。\n\n例如，对 `students` 表：\n\n- id 学号\n- class_id 班级\n- name 姓名\n- gender 性别\n- score 成绩\n\n如果要经常根据`score`列进行查询，就可以对`score`列创建索引：\n\n```sql\nALTER TABLE students\nADD INDEX idx_score (score);\n```\n\n使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`，使用列`score`的索引。\n\n索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：\n\n```sql\nALTER TABLE students\nADD INDEX idx_name_score (name, score);\n```\n\n**索引的效率取决于索引列的值是否散列，对于主键，因为主键保证绝对唯一，所以使用主键索引效率最高。**\n\n**关系数据库会自动对其创建主键索引。**\n\n> 虽然索引提高了查询效率，但是在插入、更新和删除记录使，需要同时修改索引。故而索引越多，插入等操作的速度就会更慢。\n\n### 唯一索引\n\n根据业务要求，具有唯一性约束的列（例如身份证号码）可以添加唯一索引，**从而保证这一列的值具有唯一性**。例如学生的身份证号不能重复：\n\n```sql\nALTER TABLE students\nADD UNIQUE INDEX uni_pid (pid);\n```\n\n> 通过 unique 关键字添加唯一索引\n\n也可以只添加唯一约束不创建唯一索引：\n\n```sql\nALTER TABLE students\nADD CONSTRAINT uni_pid UNIQUE (pid);\n```\n\n添加索引只不过是让数据库的查询锦上添花，没有索引数据库当然也能正常运行，因此索引可以在使用数据库的过程中逐步优化。\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"NLP 学习笔记-2","url":"/2021/02/02/nlp-learning-2/","content":"\n# 近似训练\n\n跳字模型的核心在于用 softmax 运算得到给定中心词 $w_c$ 来生成背景词 $w_o$ 的条件概率：\n\n$P(w_o \\mid w_c) = \\frac{\\text{exp}(\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c)}{ \\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)}.$\n\n该条件概率相应的对数损失：\n\n$-\\log P(w_o \\mid w_c) = -\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c + \\log\\left(\\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)\\right).$\n\n从公式中可以看出，softmax 运算考虑了背景词可能是词典 V 中的任何一个词，所以损失的计算中包含了词典所有项的累加，那么对于上千万的较大词典，每次计算梯度的开销过大。\n\n为降低计算复杂度，下面介绍两种近似训练方法：负采样（negative sampling）和层序 softmax（hierarchical softmax）。\n\n<!--more-->\n\n## 负采样\n\n\n\n# 似然函数\n\n似然函数是一种关于统计模型中的参数的函数，注意，他关注的是模型中的参数，表示模型参数的似然性。\n\n主要思想是，在已知某些观测所得到的结果时，对有关事物之性质的参数进行估值：`结果 -> 函数参数`\n\n似然函数可以理解为条件概率的逆反：条件概率是已知某个参数的值，计算发生某件事情的概率；似然函数则是根据事情发生的结果，估计参数可能是哪个值；\n\n实际生活中，当然是根据现象得出结论的情况更多。\n\n**似然函数的重要性不是它的具体取值，而是当参数变化时函数到底变小还是变大。**\n\n**对于同一个似然函数，其所代表的模型中，某项参数值有多种可能，但如果存在一个参数值，使得它的函数值（似然函数的函数值）达到最大，那么这个值就是该项参数最为 “合理”的值。**\n\n## 最大似然估计\n\n1. 选取似然函数（一般是概率密度函数或者概率质量函数）\n2. 求最大值点；一般会取 **似然函数的对数作为求最大值的函数**，这样求出来的最大值点和直接求的最大值点得到的结果相同。\n\n","tags":["NLP"],"categories":["基础知识学习"]},{"title":"NLP 学习笔记-1","url":"/2021/01/30/nlp-learning-1/","content":"\n# 词嵌入 word2vec\n\n**基于 [动手深度学习](http://zh.gluon.ai/chapter_natural-language-processing/word2vec.html)**\n\n词，是自然语言中表意的基本单元。\n\n词向量是用来表示词的向量，也可被认为是词的特征向量或表征。\n\n> 个人理解为描述 词 的一种方式\n\n词嵌入：把词映射为实数域向量的技术。\n\nword2vec 包含跳字模型和连续词袋模型。跳字模型假设基于中心词来生成背景词；连续词袋模型假设基于背景词来生成中心词。\n\n<!--more-->\n\n##  为什么不用 one-hot 向量？\n\n **one-hot 向量：**\n\n假设词典中不同字符的数量为 N，每个字符已经同一个从 0 到 N-1 的连续数值索引一一对应。\n\n如果一个字符对应的索引是 i，那么该字符对应的 one-hot 向量的第 i 位就设置为 1，其余位为 0；\n\n譬如若字库里仅有 apple（苹果），banana（香蕉），以及 pineapple（凤梨）这三个单字，则他们各自的 one-hot 向量可以为：\n\n```\napple = [1,0,0]\nbanana = [0,1,0]\npineaplle = [0,0,1]\n```\n\n> 由于电脑无法理解非数字类的数据，One-hot 编码可以将类别性数据转换成统一的数字格式，方便机器学习的算法进行处理及计算。而转换成固定维度的向量则方便机器学习算法进行线性代数上的计算。\n>\n> 另外由于一个 one-hot 向量中，绝大部分的数字都是0，所以若使用[稀疏矩阵](https://zh.wikipedia.org/wiki/稀疏矩阵)的数据结构，则可以节省电脑内存的使用量。\n\n**one-hot 向量的缺点：**\n\n虽然构造起来容易，但是 one-hot 词向量无法准确表达不同词之间的相似度（例如 余弦相似度）。\n\n**word2vec 工具的提出正是为了解决这个问题：**\n\n他将每个词表示成一个定长的向量，并使得这些向量能较好地表达不同词之间的相似和类比关系。\n\n他包含**跳字模型**和**连续词袋模型**两个模型。\n\n\n\n## 跳字模型\n\n### 核心思想\n\n基于某个词来生成它周围的词。\n\n例如，现有文本序列 `the man loves his son `给定中心词 love，设置窗口大小为 2，跳字模型关心的是，给定中心词 love，生成与它距离不超过两个词的背景词 the,man,his,son 的条件概率，即：\n\n$P('the','man','his','son' | 'love')$\n\n### 数学模型\n\n每个词被表示成两个 d 维向量，用来计算条件概率。\n\n假设某个词的词典索引为 i，它中心词时向量表示为 $v_i$ ，为背景词时向量表示为 $u_i$。\n\n设中心词 $w_c$ 在词典中索引为 $c$，背景词 $w_o$ 在词典中索引为 $o$，**给定中心词生成背景词的条件概率**可以通过对向量内积做 softmax 运算而得到：\n\n$P(w_o \\mid w_c) = \\frac{\\text{exp}(\\boldsymbol{u}_o^\\top \\boldsymbol{v}_c)}{ \\sum_{i \\in \\mathcal{V}} \\text{exp}(\\boldsymbol{u}_i^\\top \\boldsymbol{v}_c)},$\n\n> softmax 函数（归一化指数函数）：能将一个含任意实数的 K 维向量 z 压缩到另一个 K 维实向量 $\\delta(z)$ 中，使得每个元素的范围都在 (0,1) 之间，并且所有元素的和为 1 函数形式通常如下：\n>\n> $\\delta(z)_j = \\frac{e^{z_j}}{\\sum_{k=1}^{K} e^{z_k}}$  for j = 1,…, K.\n\n词典索引集为 $V = {0,1,2,...,|V|-1}$. 设给定一个长度为 T 的文本序列，设时间步 t 的词为 $w^{(t)}$ 。\n\n假设给定中心词的情况下背景词的生成相互独立，当背景窗口大小为 m 时，跳字模型的似然函数 【即给定任一中心词生成所有背景词的概率】：\n\n$\\prod_{t=1}^{T} \\prod_{-m \\leq j \\leq m,\\ j \\neq 0} P(w^{(t+j)} \\mid w^{(t)}),$\n\n\n\n### 训练跳字模型\n\n说实话这块每太看明白。。。\n\n最小化损失函数我懂，需要计算梯度来更新模型参数我也明白；\n\n为了计算梯度，我们需要词典中所有词以 $w_c$ 为中心词的条件概率这我也知道。\n\ndei某，怎么算这个条件概率嘞？按照公式的话我们是需要知道背景词向量 $u_j$ 和中心词向量 $v_c$ 的。但是他又说：\n\n> 训练结束后，对于词典中的任一索引为 i 的词，我们均得到该词作为中心词和背景词的两组词向量 $v_i$ 和 $u_i$。\n>\n> 我：？？？ 这不是循环计算？真的能得出结果吗\n>\n> 在自然语言处理应用中，一般使用跳字模型的中心词向量作为词的表征向量。\n\n## 连续词袋模型\n\n### 核心思想\n\n基于中心词在文本序列前后的背景词来生成该中心词；\n\n> 背景词 -> 中心词\n\n$P('love'|'the','man','his','son' )$\n\n\n\n数学模型和训练方式我就不搬运了，整体思路同上。\n\n\n\n据说这里看不懂可以看一篇论文 [word2vec Parameter Learning Explained](<a href=\"w2vexp.pdf\" download=\"w2vexp.pdf\">点击下载</a>)\n\n\n\n等我回头就来看","tags":["NLP"],"categories":["基础知识学习"]},{"title":"NLP 学习笔记 - 0","url":"/2021/01/30/nlp-learning/","content":"# 综述\n\n本章中，根据输入与输出的不同形式，按照 定长到定长，不定长到定长，不定长到不定长的顺序，逐步展示在自然语言处理中如何表征并变换定长的词或类别以及不定长的句子或段落序列。\n\n<!--more-->\n1. 如何用向量表示词 + 在语料库上训练词向量。\n2. 将词向量应用于求近义词和类比词 - 定长到定长\n3. 用词向量来分析文本情感：基于循环神经网络和卷积神经网络来表征时序数据\n4. 不定长到不定长任务：编码器-解码器模型、束搜索和 attention 机制\n\n","tags":["NLP"],"categories":["基础知识学习"]},{"title":"MySQL 安装教程 + 排坑","url":"/2021/01/27/mysql-install/","content":"**本教程基于 windows10(64位) 操作系统**\n\n# 下载\n\n1. 访问 [官网下载地址](https://dev.mysql.com/downloads/mysql/)\n   {% asset_img 1.PNG This is an download image %}\n\n2. 点击 `No thanks,just start my download` 跳过注册过程，直接下载压缩包。\n\n<!--more-->\n# 安装与配置\n\n- 在指定路径解压，将解压后 bin 文件的路径（`D:\\mysql-8.0.23-winx64\\bin`）添加到系统环境变量中：\n  > 我的电脑->属性->高级->环境变量\n  > 选择PATH,在其后面添加: 你的 mysql bin 文件夹的路径\n- 使用管理员身份打开 cmd：\n  > 在开始菜单中输入 cmd，选择用管理员身份打开；\n- 跳转到 mysql bin 目录下：\n  {% asset_img 2.PNG This is an bin path %}\n- 安装 mysql\n  ```\n  mysqld -install\n  ```\n- 初始化 mysql（一定要初始化！否则容易导致启动不成功）\n  ```\n  mysqld --initialize\n  ```\n- 启动服务\n  ```\n  net start mysql\n  ```\n  {% asset_img 3.PNG This is an start successfully image %}\n\n  > 这里直接写 mysql 是因为我主机服务中 mysql 的服务名就是 mysql，如果大家出现了启动不成功的情况可以自行搜索是不是服务名不同。\n\n- 登录 mysql：\n  ```\n  mysql -u root -p\n  ```\n  据说第一次登录不需要密码，直接按回车就好了，但是博主按了回车发现不行。出现报错 `ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)`\n  {% asset_img 4.PNG This is an start failed image %}\n  看来还是需要我们输入密码，下面一起找密码吧：\n  1. 打开 mysql 的根目录下名为 data 的文件夹；\n  2. 找到以 `.err` 为结尾的文件（专门记录报错信息的）并打开；\n  3. 找到自动生成的密码啦！\n   {% asset_img 5.PNG This is an password image %}\n  4. 输入密码即可~\n   {% asset_img 6.PNG This is an load successfully image %}\n\n# 通过 vscode 连接 mysql\n\n旨在利用 vscode 能更加便捷的编写并执行 SQL 代码。\n\n参考文章：[MySQL vscode开发环境搭建](https://zhuanlan.zhihu.com/p/347159257)\n\n## 基础知识\n\n> MySQL 相当于一个 shell，SQL 就是和 shell 交互的脚本语言。\n> 众所周知，与 shell 打交道的方式有两种：\n> - 一种是直接在shell中输命令执行，但是这样很难让我们看到多条shell的作用。\n> - 还有一种方式是编写 shell 脚本。在 bash 中，shell 脚本的文件名后缀可以是 .sh，在 MySQL 中，脚本的后缀名为 .sql\n\n## 安装插件\n\n1. 打开 vscode 插件商店；\n2. 搜索并安装如下两个插件：\n   - MySQL [by Jun Han]\n   - MySQL Syntax [by Jake Bathman]\n3. 以管理员身份打开 cmd；\n4. `net start mysql` 启动服务；\n5. `mysql -u root -p` 进入 MySQL 账户（密码的查找方式见上）\n6. 进入 mysql 的 shell 之后，输入命令：\n   ```\n    alter user 'root'@'localhost' identified with mysql_native_password by '123456';\n   ```\n   重置密码为 `123456`\n\n## vscode 连接本机数据库\n\n1. 打开 vscode ，点击左下角的 MYSQL 旁边的加号：\n   {% asset_img 7.PNG This is an load successfully image %}\n\n2. 在弹出的对话框中设置参数：\n   - host: 127.0.0.1\n   - username: root\n   - password: 123456 (刚设置的)\n   - 其他参数保持默认，一路回车下去\n\n## 一个栗子\n\n1. 在 MYSQL 下方的蓝色饼饼图标处右键，选择 new_query\n2. 在弹出的编辑栏中输入 SQL 指令，并以 `.sql` 为后缀名保存到本地\n3. 编辑区右键，选择 Run MySQL query\n4. 你会在编辑区右侧看到指令的执行结果。\n\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"hexo+stun 博客搭建","url":"/2021/01/26/hexo-stun/","content":"\n# 背景\n\n看到某位同学搭了自己的博客，觉得有一个记录自己成长路线的博客好像挺香的…刚好寒假时间比较充裕，是个动手的好时机~\n\nGithub Pages 功能 +  Hexo 的博客框架 + 自己喜欢的主题 = 华而有实的博客\n\n<!--more-->\n\n使用 Github Pages 搭建博客的好处：\n\n1. 免费，免费，免费！\n2. 都是静态文件，访问速度较优；\n3. 能和 git 搭配使用，管理起来都是熟悉的配方；\n\n使用 hexo 的好处：\n\n1. 简洁高效，安装简单；\n2. 有多种稳定、美观的主题可以挑选；\n3. 使用 Markdown 解析文章，符合自己平时写东西的习惯；\n\n> 当然其他框架也有各自的优点，这个选择凭各自喜好啦~\n\n**本教程以 windows 为例**\n\n\n# Github Pages\n\n**基于 [Github Pages 官方文档](https://docs.github.com/cn/github/working-with-github-pages/creating-a-github-pages-site)**\n\n前提是要有 github 账号，没有的同学们可以先去注册一个~\n\n1. 创建 Github Pages 站点：\n\n    - 新建一个仓库；\n    - 输入仓库的名称和说明（可选）。 如果您创建的是用户或组织站点，仓库名称**必须为** `<user>.github.io` 或 `<organization>.github.io` ；\n    - 设置仓库属性为 `public` ;\n    - 选择 `Initialize this repository with a README`（使用 readme 文件初始化此仓库；\n    - `create repository`\n\n2. 设置站点：\n\n    - 在站点仓库下，找到右上角 `Settings`\n\n    - 下滑，找到`Github Pages`选项卡，你能看到站点的 url 啦~\n        {% asset_img 1-1.jpg This is an github-pages image %}\n        > 这个 url 就是你网站的地址，通过它，大家就能访问到你的博客。\n\n    - Source 栏的 branch 选择 main（或者 master，总之就是除了 none 之外的那个），点击 save；\n\n    - Theme Chooser 那个不用管，因为后续要使用 hexo 的主题嘛；\n\n    - 将仓库克隆到本地，用 git 配置自己的身份信息：\n\n        ```\n        git config --global user.name \"github user name\"\n        git config --global user.email \"github user email\"\n        ```\n\n    - [添加 ssh-key](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)（注意不要设置密码）主要是为了以后 hexo 发布比较方便。\n\n\n\n# hexo\n\n**基于 [hexo](https://hexo.io/zh-cn/docs/) 官方文档**\n\n## 安装\n\n安装 hexo 之前，先来把环境搞好：\n\n- 安装 [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- 安装 Git （ 不过 github 那一步都搞好了，这里就不用了吧~）\n\n> 这里具体的安装细节提示可以直接参考各自官方文档，或者网上找找教程。\n\n现在可以安装 hexo。\n\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在`D:/blog`目录下。\n\n我使用 Windows 自带的控制台定位到`D:/blog`目录下执行以下操作：\n\n```\n$npm install -g hexo-cli\n```\n\n> 据说 linux 和 max 里是要在前面加个 sudo，不然会因为权限问题报错。\n\n装完输入 `hexo --version` 检查是否安装成功。\n\n## 建站\n\n`hexo init` 初始化文件夹；\n\n`npm install` 安装必须的插件；\n\n`hexo g` 生成静态文件；\n\n`hexo s` 将静态文件运行在本地服务器上，这个时候根据提示打开 `localhost:4000` 就能看到最基本的博客啦~\n\n`ctrl+c` 关闭本地服务器；\n\n## 与 github 连接\n\n打开 blog 根目录下的 `_config.yml` 文件，修改配置：\n\n```yml\n# URL\n## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'\nurl: https://github.com/xxx/xxx.github.io/\nroot: /xxx.github.io/\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from\n\n...\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:xxx/xxx.github.io.git\n  branch: main\n```\n\n还是在 blog 根目录下：\n\n```c\nhexo g // 编译生成静态文件（每次修改完都必须重新编译）\nhexo d // 将博客发布到 github 上\n```\n\n现在可以通过 `https://xxx.github.io` 来访问你的博客啦~\n\n\n\n# 主题 - stun\n\n博主选的是 stun 这个主题，主要是看中了她 ~~可甜可盐~~  活泼大方、简洁美观 的风格，当然她不是最简洁的，最简洁的应该是 Next 这个主题了吧（\n\n这个官方文档超级全的！！！而且步骤都很详细！！！\n\n我在这里就不瞎写了，反正写的没有官网好，照着来没错的，嗯！\n\n官网指路：[stun](https://theme-stun.github.io/docs/zh-CN/guide/quick-start.html#%E5%AE%89%E8%A3%85)\n\n\nemmmm\n\n那我写点推荐和排雷：\n\n## 统计与分析推荐\n\n首推 [谷歌分析](https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#%E8%B0%B7%E6%AD%8C%E5%88%86%E6%9E%90) ！！！ 简单好用不要钱！！！\n\n来一篇好用的配置教程：[Google Analytics怎么用，谷歌分析工具使用教程](https://www.yundianseo.com/how-to-use-google-analytics/)\n\n\n\n## 评论系统推荐\n\n博主尝试了三种评论系统，各自利弊写在下面奥：\n\n1. Disqus\n\n    优点：\n\n    - 配置简单（所以博主最先选的就是这个）\n    - 完善的后台管理机制\n    - 丰富的表情可选\n    - 支持 markdown\n\n    缺点：\n\n    - 服务器在国外，不翻墙加载不出来\n\n    - 存在广告植入\n\n    - 要评论必须有 disqus  / google / Twitter/ facebook 账户\n\n\n\n2. Valine\n\n    优点：\n\n    - 配置简单（但没有 disqus 简单）\n    - 无后端，所以加载起来很快\n    - 页面设计简洁\n    - 评论不用登陆任何账户\n    - 支持 markdown\n\n    缺点：\n\n    - 页面设计过于简洁（我试验过之后才发现，是真的很简洁，白白的，也没有点赞的功能，想要拥有一个头像都要花挺多功夫\n    - 评论可以匿名（某同学说可能会有恶意评论，博主觉得他说的有道理…\n\n\n\n3. Utterances\n\n    优点：\n\n    - 配置看上去复杂但其实很简单：\n\n        将 [utterances app (opens new window)](https://github.com/apps/utterances)安装在你博客对应的 Github 仓库中。然后，按照 stun 官网的提示修改配置项即可；\n\n    - 是一个基于 github issues 的评论系统，管理方便；\n\n    - 支持 emoji 支持评论点赞\n\n    - 支持 markdown\n\n    缺点：\n\n    - 需要登录 github 账户才能评论（是缺点也是优点吧）\n\n## bug 分享\n\n### multiline key\n\n```\n message: 'can not read a block mapping entry; a multiline key may not be an implicit key at line 7, column 9:\\n'\n \"    subtitle: 'If you shed tears when you mi ... \\n\" +\n```\n\n网上大部分说是在对应位置缺了英文空格，但我不是这个错…\n\n这里要注意，错误可能不在这一行，可能出现在它前一行：\n\n```yml\ntitle: 'Karin Lv's Blog'\nsubtitle: 'If you shed tears...\n```\n\n我就是出现在它上一行的，这里单引号中间还有一个单引号，不符合语法规则了，所以报错…\n\n去掉外层的单引号就好了！\n\n### invalid characters\n\n出现非法字符，大概率是因为在配置文件里写了中文，但没有相应的设置。\n\n博主的做法比较简单粗暴：配置文件里尽量不写中文，都改成英文 QAQ\n\n> 大家可以在网上搜一下更专业的解决办法，不要学这个懒博主（\n\n","tags":["博客搭建"],"categories":["教程类"]},{"title":"计算机网络复习 - 网络层","url":"/2021/01/26/ComputerNetworkReview-Chap4/","content":"\n# 综述\n\n通过学习这一章节，我们需要了解以下两方面内容：\n\n理解网络层服务原理：\n- 网络层服务模型\n- 网络层上的重要功能：转发和选路\n- 路由器工作原理\n- 选路算法\n\n因特网的网络层协议：\n- IP 协议\n- ICMP 协议\n- 选路协议：RIP,OSPF,BGP\n<!--more-->\n\n#  概念简介\n\n1. 网络层的**作用**：将报文段从**发送主机**传送到**接收主机**。\n\n> 每一台主机和路由器都运行网络层协议。\n>\n> 路由器：将分组从输入链路转发到输出链路。它运行的协议包括，网络层，链路层，物理层。\n>\n> 发送主机：将传输层报文段封装到网络层分组中，发送给边缘路由器。\n>\n> 接收主机：从边缘路由器接收分组，取出报文段交付给传输层。\n\n2. 网络层的主要功能：\n\n    选路：确定分组从源路由器到目的路由器的路径 – 利用各种**路由算法**来计算转发表。\n\n    转发：将分组从输入端口转移到合适的输出端口 – 根据转发表转运分组。\n\n    > 在传输分组之前，两个端系统需要建立连接。\n    >\n    > - 传输层连接：进程-进程，连接状态仅仅保存在端系统中，传输层服务在网络边缘实现\n    > - 网络层连接：主机-主机，连接状态保存在源主机，目的主机以及所有中间路由器上（路由器要保存转发表的嘛），网络层服务在网络核心实现。\n\n3. 网络服务模型\n\n    定义分组在发送主机与接收主机之间传输时的特性。\n\n    - 对单个分组提供的服务\n\n        >  保证交付；具有时延上界的保证交付；\n\n    - 对分组流提供的服务\n\n        > 有序交付；保证最小带宽；\n        > 保证最大时延抖动（分组端到端时延的最大差异）；\n\n        不同架构的网络提供的网络层服务可能不同，同一个网络也可以提供不同的网络层服务。\n\n# 虚电路和数据报网络\n\n两种基本的网络类型：\n\n**数据报网络**：提供网络层**无连接**服务\n\n**虚电路网络**：提供网络层**面向连接**服务\n\n## 虚电路 Virtual circuits\n\n网络层连接成为虚电路。\n\n虚电路是从源主机到目的主机的一条路径，类似电话电路，每条虚电路有唯一标识（虚电路号），每个分组应该携带虚电路号，表明所属的虚电路。\n\n> 传输**分组前建立虚电路**，传输结束后拆除虚电路;\n>\n> 每个路由器为经过它的虚电路维护状态（转发表项 - 进入端口，进入VC号，输出端口，输出VC号），分组携带 VC 号，每一次转发前用新的 VC 号替换分组中的 VC 号 ;\n>\n> 链路及路由器资源（带宽、缓存等）可以分配给虚电路，从而虚电路能提供**可预期的**网络服务。\n\n**信令协议：**用于 VC  的建立、维护与拆除。\n\n## 数据报网络\n\n- 分组携带目的主机地址，路由器按目的地址转发分组；\n\n- 路由器根据分组的目的地址转发分组，转发表记录目的地址到输出链路的映射；\n\n    > 实际上是存储**目的地址的范围**到**链路**的映射；\n    >\n    > 匹配规则：最长前缀匹配优先；\n\n- 转发表被选路模块修改，约1～5分钟更新一次；\n\n- 同一对主机之间传输的分组可能走不同的路径，从而可能重排序；\n\n## 数据报网络 VS 虚电路网络\n\n数据报网络：\n\n- 计算机之间交换数据：没有严格的时序要求；\n- 终端具有智能：将复杂的工作（如差错控制）推到网络边缘，以保持网络简单。\n\n虚电路网络：\n\n- 由电信网发展而来：严格时序和可靠性要求；\n- 终端无智能或很少智能：复杂工作由网络完成，以保持终端简单。\n\n\n\n# Internet 网络层协议\n\n## internet 网络层\n\n  {% asset_img 1.PNG This is an internet image %}\n\n## IPv4 数据报格式\n\n  {% asset_img 2.PNG This is an IP4 image %}\n\n## IP 数据报分片\n\n### 最大传输单元 MTU\n\nMTU：链路层数据帧可封装数据的上限；$MTU = MAX(data)$\n\n> 不同链路的 MTU 不同\n\n### 分组与重组\n\n大 IP 向比较小的 MTU 链路转发时，可以被分片 （fragmented）。\n\n1. 大 IP 分片成若干小 IP\n2. IP 分片在到达 **目的主机** 后重组（路由器只管分不管组装）\n\nIP 首部相关字段用于标识分片以及确定分片的顺序（便于在目的主机重组 IP 分组）\n\n> 涉及到的字段：总长度、标识、标志和片偏移字段。\n\n- 标识：每个分片必须携带与原始数据报相同的标识。\n- 标志位：\n    - MF（more fragments）：最后一个分片的MF=0，其余分片的 MF=1\n    - DF（don’t fragment）：DF=1 表示不允许对数据报分片\n- 片偏移量（13bits）：指示分片中的数据在原始数据报载荷中的位置（以 8 字节为单位）\n\n**分片的处理过程**\n\n根据报头长度 H 和输出线路的 MTU 为 M，原 IP 分组的总长度为 L 。\n\n一个最大分片可封装的数据为：$d = \\lfloor \\frac{M-20}{8} \\rfloor * 8 ~ Bytes$\n\n需要的总片数为： $n = \\lceil \\frac{L-20}{d} \\rceil$\n\n1. 将数据报的载荷划分成长度为 d 的若干片段（最后一个分片可能不足 d 字节）。\n\n2. 将原始报头加到每一个分片的前面，修改报头中的以下字段：\n\n    $\\text{总长度} = d + 20,  ~(1 <= i < n)$;   $ or = L-(n-1)d, ~(i = n)$\n\n    最后一个报头的 MF 位置 0，其余报头的 MF 位置 1\n\n    偏移量：$F_i = \\frac{d}{8} * (i-1), ~~~ 1\\le i \\le n$\n\n4. 计算头部检查和\n\n## IP 编址\n\n**接口：** 主机 or 路由器 与物理链路的边界。\n\n**IP 地址：**32bit 标识主机、路由器的接口。一般采用点分十进制标识（8位一组，转成十进制），例如：`127.0.0.1`\n\n**如何为接口分配 IP 地址？**\n\n-  IP 地址分为两部分，高位比特为网络号，低位比特为主机号。\n- **IP 子网：** IP 地址具有相同的网络号，**不跨越路由器**，可以彼此物理联通的接口。\n\n### 有类编址\n\n  {% asset_img 3.PNG This is an IP class image %}\n\n\n\nA,B,C 类 IP 地址可以用来给主机或路由器分配网络接口，但也有一些特殊情况。\n\n\n\n {% asset_img 4.PNG This is an IP special image %}\n\n### 子网划分\n\nIP 地址：\n\n- 网络号 NetID - 高位比特\n- 子网号 SubID - 原网络主机号部分比特\n- 主机号 HostID - 低位比特\n\n**如何确定是否划分了子网？利用多少位划分子网？**\n\n- **子网掩码**：形如 IP 地址。**取值：NetID、SubID 全部取 1， HostID 全部取 0**\n\n    > 例如：\n    >\n    > A 网默认子网掩码 ：`255.0.0.0`\n    >\n    > B 网默认子网掩码 ：`255.255.0.0`\n    >\n    > C 网默认子网掩码 ：`255.255.255.0`\n    >\n    > 借用 3 比特划分子网的 B 网的子网掩码：`255.255.224.0`\n\n- 对特定主机来说，前 32 位都看成网络号，即其子网掩码为 `255.255.255.255`\n\n- 子网地址 + 子网掩码 = 准确确定子网大小\n\n    > 例：将 子网 `201.2.3.0`, `255.255.255.0` 划分为等长的 4 个子网。\n    >\n    > 分析：\n    >\n    > C 网，主机号范围只有最后 8 位（一共可以有 256 个不同的主机号）\n    >\n    > $256 / 4 = 64$，所以将最后 8 位的前两位借为子网号，划分的四个子网如下：\n    >\n    > 1. `201.2.3.0    子网号(00)   255.255.255.192` \n    >\n    >     该子网的 IP 地址范围为 `201.2.3.0 ~ 201.2.3.63` \n    >\n    >     去掉子网 IP 地址(0)和该子网的广播地址(63)，**可分配的 IP 地址**为：`201.2.3.1 ~ 201.2.3.62`\n    >\n    > 2. `201.2.3.64   子网号(01)   255.255.255.192` \n    >\n    > 3. `201.2.3.128  子网号(10)   255.255.255.192` \n    >\n    > 4. `201.2.3.192  子网号(11)   255.255.255.192` \n\n#### 一个栗子\n\n{% asset_img 11.PNG This is an eg image %}\n\n> 其中 `0.0.0.0` 是一个特殊 IP ，表示所有待选 IP 都没有匹配到，这个特殊 IP 没有网络号。\n\n{% asset_img 12.PNG This is an eg-3 image %}\n\n\n\n### 无类域间路由 CIDR\n\nCIDR (Classless InterDomain Routing)：\n\n- 消除传统的 A、B、C 类地址界限：$NetID + SubID->Network~Prefix$\n\n- 融合子网地址与子网掩码，方便子网划分：`a.b.c.d/x` 其中 x 为前缀长度\n\n    > 例如：`200.23.16.0/23`\n    >\n    > C 类地址前 24 位都是网络号，但这里的 CIDR 地址的前缀只有 23 位。\n    >\n    > 实际上它是两个 C 类地址的组合：`200.23.16.0` 和 `200.23.17.0` (第24位分别为 0 和 1)\n\n- 子网 `201.2.2.3.64  255.255.255.192 -> 201.2.3.64/26`\n\n**优点**：\n\n- 提高 IPv4 地址空间分配效率\n\n- 提高路由效率\n    1. 将多个子网聚合为一个较大的子网\n    2. 构造超网（supernetting）\n    3. 路由聚合（route aggregation）\n\n#### 路由聚合\n\n路由表中符合聚合条件的若干条路由可以**合并成一条路由**：\n\n- 这些路由的前缀可以聚合成一个更短的前缀（称地址前缀）\n- 这些路由使用相同的下一跳\n- 路由聚合的过程可以递归进行\n\n  {% asset_img 5.PNG This is an CIDR image %}\n\n\n\n> 若个别路由不满足路由聚合的条件，可以给出一条聚合路由和若干条特定路由。\n>\n> **最长前缀匹配优先**：在所有匹配的路由表项中，选择前缀最长的路由表项。（避免路由黑洞现象【数据到达不了目标地址】）\n>\n>  {% asset_img 6.PNG This is an special CIDR image %}\n\n\n\n##  DHCP 协议\n\n**一个主机如何获得 IP 地址？**\n\n- 硬编码：静态配置（手动）\n\n    > 默认网关：数据报离开子网时，将要经过的路由器接口。数据报将通过这个路由器进一步转发到其他路径。\n\n- 动态主机配置协议 DHCP：自动获取（租赁）IP 地址、子网掩码、默认网关地址、缺省路由器、本地 DNS 服务器等配置信息。\n\n    > 即插即用；\n    >\n    > 允许地址重用（IP 地址采用租赁的形式，当一个主机不用时，归还 IP ，这个 IP 就可以分给其他主机使用）；\n    >\n    > 可以续租；\n\n**DHCP 工作过程：**\n\n- 主机**广播** “DHCP discover” 报文\n\n    > 寻找子网中的 DHCP 服务器\n\n- DHCP服务器用 “DHCP offer” 报文进行**广播**响应\n\n    > 给出推荐的IP地址及租期、其它配置信息 \n\n- 主机用 “DHCP request” 报文**广播**请求 IP 地址\n\n    > 主机选择一个 DHCP 服务器，向其请求 IP 地址 \n\n- DHCP 服务器用“DHCP ack” 报文发送IP地址\n\n    > 响应客户的请求，确认所要求的参数 \n\n- DHCP 服务器使用 UDP 端口 67，客户使用 UDP 端口 68\n\n**DHCP 的实现：**\n\n- 在应用层实现\n\n- 请求报文封装到 UDP 数据报中\n\n    > 封装 ：DHCP 应用层 -> UDP 传输层 -> IP 网络层-> Eth 链路层 -> Phy 物理层\n\n- IP 广播 -> 链路层广播（e.g. 以太网广播）\n\n## 网络地址转换 NAT\n\n**动机：**\n\n:** \n\n- IP地址支持许多用户同时上网\n- 仅为公共可访问的节点分配公用IP地址（减少需要的公用IP地址数）\n- 网络内部节点对外是不可见的（安全考虑）\n\n**NAT 实现：**\n\n- **外出的数据报**:  将数据报中的（源IP地址，源端口号）替换为（NAT IP地址，新端口号）\n- **NAT 转换表**：记录每个（源IP地址，源端口号）与（NAT IP地址，新端口号）的转换关系\n- **进入的数据报**: 取出数据报中的（目的IP地址，目的端口号）查找NAT转换表，然后用转换表中对应的（IP地址，端口号）进行替换\n\n**16比特端口号**: \n\n允许一个 NAT IP 地址同时支持65535个对外连接\n\n**NAT的使用有争议**:\n\n- 路由器应当只处理三层以下的包头（端口号在传输层）\n\n- 违反端到端原则（节点介入修改IP地址和端口号）\n\n    NAT 妨碍 P2P 应用程序：需要 NAT 穿越技术\n\n    > 方案一：静态配置 NAT ，将特定端口的连接请求转发给服务器。\n    >\n    > 方案二：利用 UPnP 互联网网关设备协议自动配置。可以学习 NAT 公共 IP 地址，并在 NAT 转换表中增删端口映射。\n    >\n    > 方案三：中继（如 Skype）NAT 内部客户-  中继 - NAT 外部客户；中继服务器桥接两个连接的分组。\n\n- 地址短缺问题应该由  IPv6 解决\n\n    \n\n## 互联网控制报文协议 ICMP\n\nICMP 协议支持主机或路由器：差错或异常报告；网络探询；\n\n**两类 ICMP 报文**：\n\n- 差错报告报文\n\n    1. 目的不可达\n\n        > 路由器无法为一个数据报找到路由或主机无法交付一个数据报，然后丢弃数据报\n\n    2. 源抑制\n\n        >  拥塞控制的一种方法：警告源节点，在路径中的某处出现了拥塞，源节点必须放慢(抑制)发送过程\n\n    3. 超时/超期 \n\n        > TTL = 0 或\n        >\n        > 目的结点在规定的时间内没有收到一个分组的所有分片\n\n    4. 参数问题 \n\n        > 路由器或目的节点发现数据报首部中的字段值出错(二义性)，丢弃该数据报\n\n    5. 重定向\n\n        > 路由器发现这个 IP 数据报不应该由自己转发，则向源主机发送重定向报文，请求重定向\n\n- 网络探询报文\n    1. 回声（Echo）请求与应答报文（Reply）\n    2. 时间戳请求与应答报文\n\n> 由于 ICMP 报文可能需要经过几个网络才能到达源节点，ICMP 报文被封装在IP包中传输。\n>\n> ICMP 通常被认为是 IP 协议的一部分，因为 IP 协议使用 ICMP 向源节点发送错误报告。\n>\n> **Ping 利用 ICMP 报文测试目的主机是否活跃**，以及去往目的主机的路径是否正常：\n>\n> - 源主机发送 Type=8，Code=0 的 Echo Request 报文\n> - 若目的主机收到，发送 Type=0，Code=0 的 Echo Response 报文\n>     源主机计算并报告 RTT\n> - 若源主机连续几次超时（收不到Echo Response），向调用者报告目的不可达\n\n**不产生 ICMP 差错报文情形：**\n\n- 对于携带 ICMP 差错报文的数据报，不再产生 ICMP 差错报文\n- 对于分片的数据报，如果**不是第一个分片**，则不产生 ICMP 差错报文 \n- 对于具有**组播(也称多播)地址**的数据报，不产生 ICMP 差错报文\n- 对于具有**特殊地址**(如 127.0.0.0 或 0.0.0.0 )，不产生 ICMP 差错报文\n\n**ICMP 报文格式：**\n\n  {% asset_img 7.PNG This is an ICMPimage %}\n\n  {% asset_img 8.PNG This is an ICMP-2 image %}\n\n\n\n## IPv6\n\n**动机：**\n\n- 32 位 IPv4 地址空间已经分配殆尽\n- 改进首部格式：快速处理、转发数据报；支持 QoS；\n\n**IPv6 与 IPv4 不兼容，但与其它所有因特网协议都兼容。**\n\n### IPv6 数据报格式\n\n- 固定长度的 40 字节基本首部\n\n- 不允许分片\n\n  {% asset_img 9.PNG This is an ipv6 image %}  \n\n### IPv6 地址\n\n128 位，使用冒号十六进制表示，每 16 位以十六进制的形式写成一组，组之间用冒号分隔，如 `8000:0:0:0:0123:4567:89AB:CDEF`\n\n地址表示的零压缩技术：可将连续的多组 0 压缩为一对冒号，如以上地址可表示为：``8000::0123:4567:89AB:CDEF`\n\nIPv6定义了三种地址类型：\n\n- 单播地址：一个特定的网络接口（一对一通信）\n- 多播地址：一组网络接口（一对多通信）\n- 任播地址（anycast）：一组网络接口中的任意一个（通常是最近的一个）\n\n### IPv6 vs. IPv4\n\n与IPv4固定头相比，IPv6的基本头中去掉了以下一些字段：\n\n- IHL：IPv6的基本头总是40字节长\n\n- 与分片相关的字段：IPv6路由器不负责分片\n\n- 头校验：计算校验和太花时间；现在的网络非常可靠，并且链路层和传输层上往往又都有校验和\n\n    \n\nIPv6基本头中增加了：\n\n- 流标签：支持对数据包区分处理\n\n    \n\n改变了以下字段的作用：\n\n- Type of Service：代之以 Traffic Class\n\n- 总长度：代之以载荷长度\n\n- Protocol：代之以Next header，允许任意扩展选项\n\n\n\n**IPv6 数据包如何穿越 IPv4 网络？**\n\n1. 报头转换\n\n    IPv4/IPv6节点（如路由器 B）在将数据报传递给 IPv4 路由器（如路由器 C）之前，将 IPv6 报头转换成 IPv4 报头\n    **缺点**：报头转换不完全，有信息丢失。\n\n2. 建立隧道\n    IPv6/IPv4 边界路由器将 IPv6 包封装到一个 IPv4 包中，送入 IPv4 网络，目的边界路由器取出IPv6包继续传输。\n    **优点**：保留原始数据报的全部信息。\n\n    {% asset_img 10.PNG This is an ipv6-ipv4 image %}  \n\n\n\n# 路由算法\n\n路由算法也就是解决选路问题的算法。\n\n选路问题：给定一组路由器和连接路由器的链路，寻找一条从源路由器到目的路由器的最佳路径。\n\n学过数据结构之后我们知道，计算机网络中的路由器网络可以抽象成图模型。\n\n- 顶点：路由器\n- 边：链路\n- 边权：链路费用（可以是带宽的倒数、拥塞程度等）\n\n- **关键问题：源到目的的最小费用路径 == 最短路径问题**\n\n    \n\n## 路由算法的分类\n\n1. 静态路由：\n\n    手工配置；路由更新慢；优先级高；\n\n2. 动态路由：\n\n    路由更新快，能定期更新且及时响应链路费用或网络拓扑变化。\n\n3. 全局算法：\n\n    所有路由器掌握完整的网络拓扑和链路费用信息。\n\n    e.g. 链路状态（LS ）路由算法。\n\n4. 分布式算法：\n\n    路由器只掌握物理相连的邻居及链路费用；\n\n    邻居间信息交换、运算的迭代过程；\n\n    e.g. 距离向量（DV）路由算法。\n\n## 链路状态（Link State）路由算法\n\n**基于图的最短路径算法 – Dijkstra 算法，得到源点到其他所有顶点的最短路径。**\n\n1. 所有节点（路由器）掌握网络拓扑和链路费用\n2. 计算一个结点（源）到所有顶点的最短路径\n3. 迭代：经过 k 次迭代后，得到到达 k 个目的结点的最短路径\n\n``` c\n// Dijkstra 算法\nInitialization: \n    N’ = {u}      // N’为已找到最短路径的节点集合，初始时只有u\n    for all nodes v    //标记源节点u到各个节点v的路径代价D(v)\n      if v adjacent to u\n          then D(v) = c(u,v)   //c(u,v)为链路(u,v)的代价\n      else D(v) = ∞ \n \n   Loop \n     find w not in N’ such that D(w) is a minimum  //下一条最短路径\n    add w to N’     //将找到最短路径的节点加入N’\n    update D(v) for all v adjacent to w and not in N’ :\n       D(v) = min( D(v), D(w) + c(w,v) )    //更新到相关节点的路径代价\n    until all nodes in N' \n```\n\n{% asset_img 13.PNG This is an dijkstra image %}  \n\n**震荡现象：** 若 A 是目的地，则下面这种情况下，最短路径循环变化，有可能一个数据报永远也到达不了 A。\n\n{% asset_img 14.PNG This is an dijkstra-problem image %}  \n\n解决办法：引入路由延迟更新算法。\n\n\n\n## 距离向量（Distance Vector）路由算法\n\n**基于 bellman-ford 算法，得到源点到所有点的最短路径。**\n\n\n\n{% asset_img 15.PNG This is an bellman-ford image %}  \n\n\n\n**特点：对每个路由器来说，只需要知道其邻居及其链路费用即可。**\n\n\n\n$D_x(y)$：从结点 x 到结点 y 的最小费用估计\n\n- x 维护距离向量 DV：$DV = \\{D_x(y):y\\in N\\}$\n\n结点 x：\n\n- 已知到达每个邻居的费用 c(x,v)\n- 维护其所有邻居 v 的距离向量：$DV = \\{D_v(y):y\\in N\\}$\n\n**核心思想**：\n\n- 每个节点不定时的将自身 DV 估计发送给邻居\n\n- 当 x 接收到最新的 DV 估计时，根据 B-F 方程更新自身的距离向量估计：\n\n    $D_x(y) <- ~~min_v \\{c(x,v) + D_v(y) ~for ~each~node~y\\in N\\}$\n\n- $D_x(y)$ 将**最终收敛于**实际最小费用 $d_x(y)$\n\n\n\n**无穷计数问题：好消息传播快，坏消息传播慢。**\n\n{% asset_img 16.PNG This is an bellman-ford-problem image %}  \n\n\n\n**消除无穷计数问题：**\n\n1. 毒性逆转：\n\n    {% asset_img 17.PNG This is an bellman-ford-problem image %}  \n\n2. 定义最大度量：\n\n    定义一个最大的有效费用值，如 15 跳，16 跳表示无穷大。\n\n    {% asset_img 18.PNG This is an mmd image %}  \n\n    无穷计数不会真正的无穷下去，会在有限的步数内反应网络状态。比如上图中的 R1,R2 已经不可达了。\n\n## 层次路由\n\n将任意规模的网络抽象成一张图，这样计算路由过于理想化。\n\n在实际（大规模）网络中不可行：\n\n> 1. 路由表几乎无法存储；\n> 2. 路由计算过程的信息交换量巨大，会淹没电路。\n\n考虑网络管理自治性的问题：每个网络的管理可能都期望自主控制内部路由算法。\n\n### 自治系统 AS（autonomous systems）\n\n聚合路由器为一个区域：自治系统。\n\n同一个 AS 内的路由器运行相同的路由协议（算法）。\n\n- 自治系统内部路由协议\n- 不同的 AS 内的路由器可以运行不同的 AS 内部路由协议\n\n网关路由器：\n\n- 在 AS 边缘\n- 通过链路连接其他的 AS 网关路由器\n\n互连的 AS：\n\n- 转发表由 AS 内部路由算法与 AS 间路由算法共同设置。\n\n{% asset_img 19.PNG This is an AS image %}  \n\n**举个栗子：**\n\n{% asset_img 20.PNG This is an eg-1 image %}  \n\n{% asset_img 21.PNG This is an eg-2 image %}  \n\n热土豆路由协议：选择最近的网关路由器。\n\n{% asset_img 22.PNG This is an eg-3 image %}  \n\n\n\n# 路由协议\n\nInternet 采用层次路由。\n\nAS 内部路由协议也称内部网关协议IGP（Interior Gateway Protocols），\n\n最常见的有:\n\n- 路由信息协议 RIP（Routing Information Protocol）：较低层ISP和企业网中使用\n- 开放最短路径优先协议 OSPF（Open Shortest Path First）：较顶层 ISP 中使用\n\n外部网关协议 EGP（Exterior Gateway Protocols），目前只有： BGP（Border Gateway Protocol）\n\n## RIP\n\nRIP 采用**距离矢量选路算法**：\n\n- 距离度量：跳步数（MAX = 15 hops），每条链路一个跳步。\n- RIP 响应报文（RIP通告）\n    距离向量封装在RIP响应报文中传输；\n    每个报文携带一个目的子网列表（最多包含25个子网），以及到每个目的子网的最短距离；\n\n- RIP 响应报文的发送：\n    相邻路由器之间大约每 30 秒交换一次 RIP 响应报文\n    RIP 报文封装在 UDP 报文中发送，使用 UDP 端口 520\n\n    > RIP是一个应用层协议，其路由表示利用一个称作 route-d（daemon）的应用层进程进行管理。\n    >\n    > RIP：是应用层协议，但完成的是网络层功能。\n\n**RIP 链路的失效和恢复：**\n\n- 经过该邻居的路由不可用：需要重新计算路由\n\n- 向邻居发送新的通告\n\n- 若转发表改变，邻居再依次向外发送通告\n\n- 链路失效信息能否快速传播到全网？\n\n    可能发生无穷计数问题，但因为规定了最大跳数，故而可以在有限时间内收敛到正确状态。\n\n- **毒性逆转技术** 用于预防乒乓环路。\n\n> RIP 认为 15 跳步以内有效，16跳步及以上则认为网络不可达。所以 RIP 适用于小规模的自治系统，超过 15 跳的自治网络就不再适用了。","tags":["计算机网络"],"categories":["复习笔记"]}]